////////////////////////////////////////////////////////////////////////////////
// Helper
////////////////////////////////////////////////////////////////////////////////
timer_state(H, I, T-1)@next :- timer_svc(H, I, T);
timer_state(H, I, T-1)@next :- timer_state(H, I, T), notin timer_cancel(H, I), T > 1;
timeout(H, I) :- timer_state(H, I, 1);

////////////////////////////////////////////////////////////////////////////////
// Object
////////////////////////////////////////////////////////////////////////////////

entries(Obj, Pos, Value)@next :- entries(Obj, Pos, Value);
entries_summary(Obj, count<Pos>, max<Pos>) :- entries(Obj, Pos, _);

// reply to a `req_maxpos` request for the maximum position written
rep_maxpos(Seq, Obj, Count, MaxPos)@async :- req_maxpos(Obj, Seq),
                                             entries_summary(Obj, Count, MaxPos);

////////////////////////////////////////////////////////////////////////////////
// Sequencer Initialization
////////////////////////////////////////////////////////////////////////////////

// provided the sequencer is not initialized, send a `req_maxpos` request to
// every object that we have not yet received replies. the replies will be
// used to calculate the initial soft state counter of the sequencer
req_maxpos(Obj, Seq)@async :- object(Seq, Obj),
                              notin maxpos_replies(Seq, Obj, _, _),
                              notin seq(Seq, _);

// persist each `rep_maxpos` reply until the sequencer is initialized
maxpos_replies(Seq, Obj, Count, MaxPos)      :- rep_maxpos(Seq, Obj, Count, MaxPos);
maxpos_replies(Seq, Obj, Count, MaxPos)@next :- maxpos_replies(Seq, Obj, Count, MaxPos),
                                                notin seq(Seq, _);

// sequencers that are missing maxpos replies from all objects
missing_maxpos_replies(Seq) :- object(Seq, Obj), notin maxpos_replies(Seq, Obj, _, _);

// non-empty objects contribute candidates maxpos + 1
maybe_seq_init(Seq, MaxPos + 1) :- maxpos_replies(Seq, _, Count, MaxPos),
                                   notin missing_maxpos_replies(Seq),
                                   Count > 0;

// empty objects contribute candidate maxpos of 0. note that 0 is also a valid
// maxpos resposne from a non-empty object, but it would be transformed into
// the value 1 by the previosu rule.
maybe_seq_init(Seq, 0) :- maxpos_replies(Seq, _, Count, _),
                          notin missing_maxpos_replies(Seq),
                          Count == 0;

// final initialization value. without the intermediate seq_init table c4
// throws an assertion failure.
seq_init(Seq, max<InitPos>) :- maybe_seq_init(Seq, InitPos);
seq(Seq, InitPos)@next :- seq_init(Seq, InitPos), notin seq(Seq, _);

////////////////////////////////////////////////////////////////////////////////
// Sequencer Next Op
////////////////////////////////////////////////////////////////////////////////

seq(Server, Seq)@next     :- seq(Server, Seq), notin req_next(Server, _, _);
seq(Server, Seq + 1)@next :- seq(Server, Seq), req_next(Server, _, _);

// reply to the request with the minimum value. requests must be constructed by
// clients in the model such that values are unique so that there is exactly one
// tuple defined by the min value in any given batch of requests.
req_next_min_val(Server, min<Value>) :- req_next(Server, _, Value);
req_next(Server, Client, Value)@next :- req_next(Server, Client, Value),
                                        notin req_next_min_val(Server, Value);
rep_next(Client, Server, Seq, Value)@async :- seq(Server, Seq),
                                              req_next(Server, Client, Value),
                                              req_next_min_val(Server, Value);

// TODO: keep messages around if we haven't yet initialized

// WIP: assign all pending requests a sequence number in current timestep
//
//req_next_cnt(Server, count<Value>) :- req_next(Server, _, Value);
//seq(Server, Seq + Cnt)@next :- seq(Server, Seq), req_next_cnt(Server, Cnt);
// assign the request with the minimum value the current sequence number
//req_next_seq(Server, min<Value>, Seq) :- req_next(Server, _, Value),
//                                         seq(Server, Seq);
//req_next_seq_max(Server, max<Seq>) :- req_next_seq(Server, _, Seq);
//req_next_seq(Server, min<Value>, Seq + 1) :- req_next(Server, _, Value),
//                                             req_next_seq_max(Server, Seq),
//                                             notin req_next_seq(Server, Value, _);
//rep_next(Client, Server, Seq, Value)@async :- seq(Server, Seq),
//                                              req_next(Server, Client, Value),
//                                              req_next_min_val(Server, Value);

////////////////////////////////////////////////////////////////////////////////
// Client append handling
////////////////////////////////////////////////////////////////////////////////

// replies from sequencer requesting new log position
next_replies(Client, Server, Seq, Value) :- rep_next(Client, Server, Seq, Value);
next_replies(Client, Server, Seq, Value)@next :- next_replies(Client, Server, Seq, Value);

// when we get a reply, cancel any timer associated with it
timer_cancel(Client, Value) :- next_replies(Client, _, _, Value);

// client requests that have not yet been assigned a position from the sequencer
// because no reply from the sequencer has been received.
next_replies_val(C, S, V) :- next_replies(C, S, _, V);
missing_pos(C, S, V) :- client_req(C, S, V),
                        notin next_replies_val(C, S, V);

// inflight requests to the sequencer for a log position. doesn't include
// requests with replies, or requests that are older than a timeout.
pending_pos(C, S, V)@next :- pending_pos(C, S, V),
                             missing_pos(C, S, V),
                             notin timeout(C, V);

// requests for new positions ready to go to the sequencer. these are the client
// requests with missing positions that are not currently pending.
next_reqs(C, S, V) :- missing_pos(C, S, V),
                      notin pending_pos(C, S, V);

// start a timer for each request
// TODO: notice that we identify everything as S,V pairs, except timeout. That's
// probably wrong in the face of multiple sequencers.
timer_svc(Client, Value, 2) :- next_reqs(Client, _, Value);

// add requests to the pending set
pending_pos(C, S, V)@next :- next_reqs(C, S, V);

// send out the requests to sequencer
req_next(Server, Client, Value)@async :- next_reqs(Client, Server, Value);

client_req(Client, Server, Value)@next :- client_req(Client, Server, Value);

// TODO: once we are ready to send a write to an object, select a reply. There
// might be multiple. Or maybe we just allow duplicates?
//mod("s0", A, N, A - NQ) :- a(Node, A), n(Node, N), nq(Node, A, N, NQ);
//nq(Node, A, N, N * Q)   :- a(Node, A), n(Node, N), q(Node, A, N, Q);
//q(Node, A, N, A / N)    :- a(Node, A), n(Node, N);

////////////////////////////////////////////////////////////////////////////////

pre(S, Q) :- seq(S, Q);
post(S, Q) :- pre(S, Q);

// use unique numeric values
client_req("c0", "s0", 1)@1;

// nodes know about all the objects
object("s0", "o0")@1;
object("s0", "o1")@1;
object("s0", "o2")@1;
//object("s0", "o3")@1;
object(Node, Obj)@next :- object(Node, Obj);

entries("o0", 0, "a")@1;
entries("o1", 1, "b")@1;
entries("o2", 2, "c")@1;
//entries("o3", 3, "d")@1;
