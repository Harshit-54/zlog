////////////////////////////////////////////////////////////////////////////////
// Helper
////////////////////////////////////////////////////////////////////////////////
timer_state(H, I, T-1)@next :- timer_svc(H, I, T);
timer_state(H, I, T-1)@next :- timer_state(H, I, T), notin timer_cancel(H, I), T > 1;
timeout(H, I) :- timer_state(H, I, 1);

////////////////////////////////////////////////////////////////////////////////
// Object
////////////////////////////////////////////////////////////////////////////////

entries(Obj, Pos, Value)@next :- entries(Obj, Pos, Value);
entries_summary(Obj, count<Pos>, max<Pos>) :- entries(Obj, Pos, _);

// reply to a `req_maxpos` request for the maximum position written
rep_maxpos(Seq, Obj, Count, MaxPos)@async :- req_maxpos(Obj, Seq),
                                             entries_summary(Obj, Count, MaxPos);

// remove write requests with positions that have already been written
req_write_ok(O, C, P, V) :- req_write(O, C, P, V),
                            notin entries(O, P, _);
req_write_ok(O, C, P, V)@next :- req_write_ok(O, C, P, V),
                                 notin req_write_choice(O, C, P, V);

// we handle only one write per timestep. we need to winnow down the set.  find
// the req with minimum value. by construction clients deal in unique values, so
// the result will correspond to a single client.
req_write_minval(O, min<V>) :- req_write_ok(O, _, _, V);

// its possible that there are multiple requests for the same value pending
// under different positions. take the minimum.
req_write_choice(O, C, min<P>, V) :- req_write_ok(O, C, P, V),
                                     req_write_minval(O, V);

entries(Obj, Pos, Value)@next :- req_write_choice(Obj, _, Pos, Value);
ack_write(C, O, P, V)@async :- req_write_choice(O, C, P, V);

////////////////////////////////////////////////////////////////////////////////
// Sequencer Initialization
////////////////////////////////////////////////////////////////////////////////

// provided the sequencer is not initialized, send a `req_maxpos` request to
// every object that we have not yet received replies. the replies will be
// used to calculate the initial soft state counter of the sequencer
req_maxpos(Obj, Seq)@async :- object(Seq, Obj),
                              notin maxpos_replies(Seq, Obj, _, _),
                              notin seq(Seq, _);

// persist each `rep_maxpos` reply until the sequencer is initialized
maxpos_replies(Seq, Obj, Count, MaxPos)      :- rep_maxpos(Seq, Obj, Count, MaxPos);
maxpos_replies(Seq, Obj, Count, MaxPos)@next :- maxpos_replies(Seq, Obj, Count, MaxPos),
                                                notin seq(Seq, _);

// sequencers that are missing maxpos replies from all objects
missing_maxpos_replies(Seq) :- object(Seq, Obj), notin maxpos_replies(Seq, Obj, _, _);

// non-empty objects contribute candidates maxpos + 1
maybe_seq_init(Seq, MaxPos + 1) :- maxpos_replies(Seq, _, Count, MaxPos),
                                   notin missing_maxpos_replies(Seq),
                                   Count > 0;

// empty objects contribute candidate maxpos of 0. note that 0 is also a valid
// maxpos resposne from a non-empty object, but it would be transformed into
// the value 1 by the previosu rule.
maybe_seq_init(Seq, 0) :- maxpos_replies(Seq, _, Count, _),
                          notin missing_maxpos_replies(Seq),
                          Count == 0;

// final initialization value. without the intermediate seq_init table c4
// throws an assertion failure.
seq_init(Seq, max<InitPos>) :- maybe_seq_init(Seq, InitPos);
seq(Seq, InitPos)@next :- seq_init(Seq, InitPos), notin seq(Seq, _);

////////////////////////////////////////////////////////////////////////////////
// Sequencer Next Op
////////////////////////////////////////////////////////////////////////////////

seq(Server, Seq)@next     :- seq(Server, Seq), notin req_next(Server, _, _);
seq(Server, Seq + 1)@next :- seq(Server, Seq), req_next(Server, _, _);

// reply to the request with the minimum value. requests must be constructed by
// clients in the model such that values are unique so that there is exactly one
// tuple defined by the min value in any given batch of requests.
req_next_min_val(Server, min<Value>) :- req_next(Server, _, Value), seq(Server, _);
req_next(Server, Client, Value)@next :- req_next(Server, Client, Value),
                                        notin req_next_min_val(Server, Value);
rep_next(Client, Server, Seq, Value)@async :- seq(Server, Seq),
                                              req_next(Server, Client, Value),
                                              req_next_min_val(Server, Value);

// TODO: keep messages around if we haven't yet initialized

// WIP: assign all pending requests a sequence number in current timestep
//
//req_next_cnt(Server, count<Value>) :- req_next(Server, _, Value);
//seq(Server, Seq + Cnt)@next :- seq(Server, Seq), req_next_cnt(Server, Cnt);
// assign the request with the minimum value the current sequence number
//req_next_seq(Server, min<Value>, Seq) :- req_next(Server, _, Value),
//                                         seq(Server, Seq);
//req_next_seq_max(Server, max<Seq>) :- req_next_seq(Server, _, Seq);
//req_next_seq(Server, min<Value>, Seq + 1) :- req_next(Server, _, Value),
//                                             req_next_seq_max(Server, Seq),
//                                             notin req_next_seq(Server, Value, _);
//rep_next(Client, Server, Seq, Value)@async :- seq(Server, Seq),
//                                              req_next(Server, Client, Value),
//                                              req_next_min_val(Server, Value);

////////////////////////////////////////////////////////////////////////////////
// Client append handling
////////////////////////////////////////////////////////////////////////////////

// replies from sequencer requesting new log position
next_replies(Client, Server, Seq, Value) :- rep_next(Client, Server, Seq, Value);
next_replies(Client, Server, Seq, Value)@next :- next_replies(Client, Server, Seq, Value);

// when we get a reply, cancel any timer associated with it
timer_cancel(Client, Value) :- next_replies(Client, _, _, Value);

// client requests that have not yet been assigned a position from the sequencer
// because no reply from the sequencer has been received.
next_replies_val(C, S, V) :- next_replies(C, S, _, V);
missing_pos(C, S, V) :- client_req(C, S, V),
                        notin next_replies_val(C, S, V);

// inflight requests to the sequencer for a log position. doesn't include
// requests with replies, or requests that are older than a timeout.
pending_pos(C, S, V)@next :- pending_pos(C, S, V),
                             missing_pos(C, S, V),
                             notin timeout(C, V);

// requests for new positions ready to go to the sequencer. these are the client
// requests with missing positions that are not currently pending.
next_reqs(C, S, V) :- missing_pos(C, S, V),
                      notin pending_pos(C, S, V);

// start a timer for each request
// TODO: notice that we identify everything as S,V pairs, except timeout. That's
// probably wrong in the face of multiple sequencers.
timer_svc(Client, Value, 5) :- next_reqs(Client, _, Value);

// add requests to the pending set
pending_pos(C, S, V)@next :- next_reqs(C, S, V);

// send out the requests to sequencer
req_next(Server, Client, Value)@async :- next_reqs(Client, Server, Value);

client_req(Client, Server, Value)@next :- client_req(Client, Server, Value);

// TODO: once we are ready to send a write to an object, select a reply. There
// might be multiple. Or maybe we just allow duplicates?
//mod("s0", A, N, A - NQ) :- a(Node, A), n(Node, N), nq(Node, A, N, NQ);
//nq(Node, A, N, N * Q)   :- a(Node, A), n(Node, N), q(Node, A, N, Q);
//q(Node, A, N, A / N)    :- a(Node, A), n(Node, N);

// which client requests have not successfully written to an object
write_acks(C, O, P, V)      :- ack_write(C, O, P, V);
write_acks(C, O, P, V)@next :- write_acks(C, O, P, V);
missing_write_acks(C, V) :- client_req(C, _, V), notin write_acks(C, _, _, V);

// for each write that needs to be completed, do we have a position assigned?
write(C, V, min<P>) :- missing_write_acks(C, V), next_replies(C, _, P, V);

// now compute P mod Nobjs == Oid
num_objects(C, count<O>) :- client_object(C, _, O);
an(C, P, O)              :- write(C, _, P), num_objects(C, O);
q(Node, A, N, A / N)     :- an(Node, A, N);
nq(Node, A, N, N * Q)    :- an(Node, A, N), q(Node, A, N, Q);
mod(Node, A, N, A - NQ)  :- an(Node, A, N), nq(Node, A, N, NQ);

// map Oid for write request to object process name. holy shit
req_write(O, C, P, V)@async :- write(C, V, P),
                               num_objects(C, Nobjs),
                               mod(C, P, Nobjs, Oid),
                               client_object(C, O, Oid);

////////////////////////////////////////////////////////////////////////////////

pre(S, Q) :- seq(S, Q);
post(S, Q) :- pre(S, Q);

// use unique numeric values
client_req("c0", "s0", 1)@1;
client_req("c1", "s0", 2)@1;
client_req("c1", "s0", 3)@1;

object("s0", "o0")@1;
object("s0", "o1")@1;
object("s0", "o2")@1;

client_object("c0", "o0", 0)@1;
client_object("c0", "o1", 1)@1;
client_object("c0", "o2", 2)@1;
client_object("c1", "o0", 0)@1;
client_object("c1", "o1", 1)@1;
client_object("c1", "o2", 2)@1;

object(Node, Obj)@next :- object(Node, Obj);
client_object(Node, Obj, Oid)@next :- client_object(Node, Obj, Oid);

entries("o0", 0, 0)@1;
entries("o1", 1, 1)@1;
entries("o2", 2, 2)@1;
