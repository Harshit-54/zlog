////////////////////////////////////////////////////////////////////////////////
// Object
////////////////////////////////////////////////////////////////////////////////

entries(Obj, Pos, Value)@next :- entries(Obj, Pos, Value);
entries_summary(Obj, count<Pos>, max<Pos>) :- entries(Obj, Pos, _);

// reply to a `req_maxpos` request for the maximum position written
rep_maxpos(Seq, Obj, Count, MaxPos)@async :- req_maxpos(Obj, Seq),
                                             entries_summary(Obj, Count, MaxPos);

////////////////////////////////////////////////////////////////////////////////
// Sequencer Initialization
////////////////////////////////////////////////////////////////////////////////

// provided the sequencer is not initialized, send a `req_maxpos` request to
// every object that we have not yet received replies. the replies will be
// used to calculate the initial soft state counter of the sequencer
req_maxpos(Obj, Seq)@async :- object(Seq, Obj),
                              notin maxpos_replies(Seq, Obj, _, _),
                              notin seq(Seq, _);

// persist each `rep_maxpos` reply until the sequencer is initialized
maxpos_replies(Seq, Obj, Count, MaxPos)      :- rep_maxpos(Seq, Obj, Count, MaxPos);
maxpos_replies(Seq, Obj, Count, MaxPos)@next :- maxpos_replies(Seq, Obj, Count, MaxPos),
                                                notin seq(Seq, _);

// sequencers that are missing maxpos replies from all objects
missing_maxpos_replies(Seq) :- object(Seq, Obj), notin maxpos_replies(Seq, Obj, _, _);

// non-empty objects contribute candidates maxpos + 1
maybe_seq_init(Seq, MaxPos + 1) :- maxpos_replies(Seq, _, Count, MaxPos),
                                   notin missing_maxpos_replies(Seq),
                                   Count > 0;

// empty objects contribute candidate maxpos of 0. note that 0 is also a valid
// maxpos resposne from a non-empty object, but it would be transformed into
// the value 1 by the previosu rule.
maybe_seq_init(Seq, 0) :- maxpos_replies(Seq, _, Count, _),
                          notin missing_maxpos_replies(Seq),
                          Count == 0;

// final initialization value. without the intermediate seq_init table c4
// throws an assertion failure.
seq_init(Seq, max<InitPos>) :- maybe_seq_init(Seq, InitPos);
seq(Seq, InitPos)@next :- seq_init(Seq, InitPos), notin seq(Seq, _);

////////////////////////////////////////////////////////////////////////////////
// Sequencer Next Op
////////////////////////////////////////////////////////////////////////////////

seq(Server, Seq)@next     :- seq(Server, Seq), notin req_next(Server, _, _);
seq(Server, Seq + 1)@next :- seq(Server, Seq), req_next(Server, _, _);

// reply to the request with the minimum value. make sure to arrange for
// all values to be unique
req_next_min_val(Server, min<Value>) :- req_next(Server, _, Value);
rep_next(Client, Server, Seq, Value)@async :- seq(Server, Seq),
                                              req_next(Server, Client, Value),
                                              req_next_min_val(Server, Value);

// trying to do all the assignments in the current timestep
//
//req_next_cnt(Server, count<Value>) :- req_next(Server, _, Value);
//seq(Server, Seq + Cnt)@next :- seq(Server, Seq), req_next_cnt(Server, Cnt);
// assign the request with the minimum value the current sequence number
//req_next_seq(Server, min<Value>, Seq) :- req_next(Server, _, Value),
//                                         seq(Server, Seq);
//req_next_seq_max(Server, max<Seq>) :- req_next_seq(Server, _, Seq);
//req_next_seq(Server, min<Value>, Seq + 1) :- req_next(Server, _, Value),
//                                             req_next_seq_max(Server, Seq),
//                                             notin req_next_seq(Server, Value, _);

////////////////////////////////////////////////////////////////////////////////

next_replies(Client, Server, Seq, Value) :- rep_next(Client, Server, Seq, Value);
next_replies(Client, Server, Seq, Value)@next :- next_replies(Client, Server, Seq, Value);

req_next(Server, Client, Value)@async :- client_req(Client, Server, Value),
                                         notin next_replies(Client, Server, _, Value);

client_req(Client, Server, Value)@next :- client_req(Client, Server, Value);

//mod("s0", A, N, A - NQ) :- a(Node, A), n(Node, N), nq(Node, A, N, NQ);
//nq(Node, A, N, N * Q)   :- a(Node, A), n(Node, N), q(Node, A, N, Q);
//q(Node, A, N, A / N)    :- a(Node, A), n(Node, N);

////////////////////////////////////////////////////////////////////////////////

pre(S, Q) :- seq(S, Q);
post(S, Q) :- pre(S, Q);

// use unique numeric values
client_req("c0", "s0", 1)@1;

// nodes know about all the objects
object("s0", "o0")@1;
object("s0", "o1")@1;
object("s0", "o2")@1;
//object("s0", "o3")@1;
object(Node, Obj)@next :- object(Node, Obj);

entries("o0", 0, "a")@1;
entries("o1", 1, "b")@1;
entries("o2", 2, "c")@1;
//entries("o3", 3, "d")@1;
