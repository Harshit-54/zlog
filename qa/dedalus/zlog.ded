////////////////////////////////////////////////////////////////////////////////
// Object
////////////////////////////////////////////////////////////////////////////////

entries(Obj, Pos, Value)@next :- entries(Obj, Pos, Value);
entries_summary(Obj, count<Pos>, max<Pos>) :- entries(Obj, Pos, _);

// reply to a `req_maxpos` request for the maximum position written
rep_maxpos(Seq, Obj, Count, MaxPos)@async :- req_maxpos(Obj, Seq),
                                             entries_summary(Obj, Count, MaxPos);

////////////////////////////////////////////////////////////////////////////////
// Sequencer Initialization
////////////////////////////////////////////////////////////////////////////////

// provided the sequencer is not initialized, send a `req_maxpos` request to
// every object. the replies will be used to calculate the initial soft state.
req_maxpos(Obj, Seq)@async :- object(Seq, Obj), notin seq(Seq, _);

// persist each `rep_maxpos` reply until the sequencer is initialized
maxpos_replies(Seq, Obj, Count, MaxPos)      :- rep_maxpos(Seq, Obj, Count, MaxPos);
maxpos_replies(Seq, Obj, Count, MaxPos)@next :- maxpos_replies(Seq, Obj, Count, MaxPos),
                                                notin seq(Seq, _);

// sequencers that are missing maxpos replies from all objects
missing_maxpos_replies(Seq) :- object(Seq, Obj), notin maxpos_replies(Seq, Obj, _, _);

// non-empty objects contribute candidates maxpos + 1
maybe_seq_init(Seq, MaxPos + 1) :- maxpos_replies(Seq, _, Count, MaxPos),
                                   notin missing_maxpos_replies(Seq),
                                   Count > 0;

// empty objects contribute candidate maxpos of 0. note that 0 is also a valid
// maxpos resposne from a non-empty object, but it would be transformed into
// the value 1 by the previosu rule.
maybe_seq_init(Seq, 0) :- maxpos_replies(Seq, _, Count, _),
                          notin missing_maxpos_replies(Seq),
                          Count == 0;

// final initialization value. without the intermediate seq_init table c4
// throws an assertion failure.
seq_init(Seq, max<InitPos>) :- maybe_seq_init(Seq, InitPos);
seq(Seq, InitPos) :- seq_init(Seq, InitPos), notin seq(Seq, _);

////////////////////////////////////////////////////////////////////////////////
// Sequencer Next Op
////////////////////////////////////////////////////////////////////////////////

seq(Server, Seq)@next     :- seq(Server, Seq), notin req_next(Server, _, _);
seq(Server, Seq + 1)@next :- seq(Server, Seq), req_next(Server, _, _);

rep_next(Client, Server, Seq, Value)@async :- seq(Server, Seq),
                                              req_next(Server, Client, Value);

////////////////////////////////////////////////////////////////////////////////

next_replies(Client, Server, Seq, Value) :- rep_next(Client, Server, Seq, Value);
next_replies(Client, Server, Seq, Value)@next :- next_replies(Client, Server, Seq, Value);

req_next(Server, Client, Value)@async :- client_req(Client, Server, Value),
                                         notin next_replies(Client, Server, _, Value);

client_req(Client, Server, Value)@next :- client_req(Client, Server, Value);

////////////////////////////////////////////////////////////////////////////////

pre(S, Q) :- seq(S, Q);
post(S, Q) :- pre(S, Q);

client_req("c0", "s0", "v0")@1;

// nodes know about all the objects
object("s0", "o0")@1;
object("s0", "o1")@1;
object("s0", "o2")@1;
//object("s0", "o3")@1;
object(Node, Obj)@next :- object(Node, Obj);

entries("o0", 0, "a")@1;
entries("o1", 1, "b")@1;
entries("o2", 2, "c")@1;
//entries("o3", 3, "d")@1;
