////////////////////////////////////////////////////////////////////////////////
// Object
////////////////////////////////////////////////////////////////////////////////

entries(Obj, Pos, Value)@next :- entries(Obj, Pos, Value);
entries_summary(Obj, count<Pos>, max<Pos>) :- entries(Obj, Pos, _);

// reply to a `req_maxpos` request for the maximum position written
rep_maxpos(Seq, Obj, Count, MaxPos)@async :- req_maxpos(Obj, Seq),
                                             entries_summary(Obj, Count, MaxPos);

////////////////////////////////////////////////////////////////////////////////
// Sequencer Initialization
////////////////////////////////////////////////////////////////////////////////

// provided the sequencer is not initialized, send a `req_maxpos` request to
// every object. the replies will be used to calculate the initial soft state.
req_maxpos(Obj, Seq)@async :- object(Seq, Obj), notin seq(Seq, _);

// persist each `rep_maxpos` reply until the sequencer is initialized
maxpos_replies(Seq, Obj, Count, MaxPos)      :- rep_maxpos(Seq, Obj, Count, MaxPos),
                                                notin seq(Seq, _);
maxpos_replies(Seq, Obj, Count, MaxPos)@next :- maxpos_replies(Seq, Obj, Count, MaxPos),
                                                notin seq(Seq, _);

// TODO: predicate on non-initialization to empty table after init?
// sequencers that are missing maxpos replies from all objects
missing_maxpos_replies(Seq) :- object(Seq, Obj),
                               notin maxpos_replies(Seq, Obj, _, _);

// calculate the maximum position across non-empty objects provided that
// replies have been received from all objects
nonempty_maxpos(Seq, max<MaxPos>) :- maxpos_replies(Seq, _, Count, MaxPos),
                                     notin missing_maxpos_replies(Seq),
                                     Count > 0;

// if a position has been written, then the sequencer state should be
// initialized to the position immediately following the max position
maybe_seq_init(Seq, MaxPos + 1) :- nonempty_maxpos(Seq, MaxPos);

// if all objects are empty the sequencer state is initialized to zero.  here
// we contribute 0 for all empty objects, and then next take the max over all
// rows to select the correct result if any non-empty object exists.
maybe_seq_init(Seq, 0) :- maxpos_replies(Seq, _, Count, _),
                          notin missing_maxpos_replies(Seq),
                          Count == 0;

// final initialization value. TODO sticking seq_init into seq during the
// current timestep makes C4 barf, which is unfortunate because id like to do
// that to handle req_next requests in the same timestep as initializaiton.
seq_init(Seq, max<InitPos>) :- maybe_seq_init(Seq, InitPos);
seq(Seq, InitPos)@next  :- seq_init(Seq, InitPos);

seq(Server, Seq)@next     :- seq(Server, Seq), notin req_next(Server, _, _);
seq(Server, Seq + 1)@next :- seq(Server, Seq), req_next(Server, _, _);

rep_next(Client, Server, Seq, Value)@async :- seq(Server, Seq),
                                              req_next(Server, Client, Value);

////////////////////////////////////////////////////////////////////////////////

// send requests to the sequencer until we get a reply
need_req(Client, Server, Value) :- client_req(Client, Server, Value),
                                   notin rep_next(Client, Server, _, Value);
req_next(Server, Client, Value)@async :- need_req(Client, Server, Value);
client_req(Client, Server, Value)@next :- need_req(Client, Server, Value);

////////////////////////////////////////////////////////////////////////////////

pre(S, Q) :- seq(S, Q);
post(S, Q) :- pre(S, Q);

client_req("c0", "s0", "v0")@1;

// nodes know about all the objects
object("s0", "o0")@1;
object("s0", "o1")@1;
object("s0", "o2")@1;
//object("s0", "o3")@1;
object(Node, Obj)@next :- object(Node, Obj);

entries("o0", 0, "a")@1;
entries("o1", 1, "b")@1;
entries("o2", 2, "c")@1;
//entries("o3", 3, "d")@1;
